# 栈

## 特点

- 本质上属于一种缓存

- LIFO（Last In First Out） 后入先出
- 回溯特性

其中**回溯特性**是指 **栈有从当前依次向前追溯历史记录也就是“回溯历史”特性**，**遍历顺序和处理顺序是相反的**，**递归**也有此特点。



#  队列

## 特点

- 本质上属于一种**缓存**

- FIFO （First In First Out）先入先出
- 重现特性

重现特性是指 **队列有按照原来顺序从前到后“重现历史”的特性**，**遍历顺序和处理顺序是相同的**，例在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。



# 优先队列

优先队列是一种**抽象数据类型** ，它表示了一组值和对这些值的操作。

许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素。**输入可以无限制**。

一个合适的数据结构应该支持两种操作：**删除最大元素** 和**插入元素** 。这种数据类型叫做**优先队列**。

## 堆有序

当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为**堆有序** 。

**最大堆**：在堆有序的二叉树中，每个结点都小于等于它的父结点（如果有的话）。从任意结点向上，我们都能得到一列非递减的元素；从任意结点向下，我们都能得到一列非递增的元素。



## 堆操作

### 有序化

堆的操作会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。我们称这个过程叫做**堆的有序化** （reheapifying）。

具体而言，有如下两个过程：

当某个结点的优先级上升（或是在堆底加入一个新的元素）时，我们需要**由下至上** 恢复堆的顺序 **swim()**。当某个结点的优先级下降（例如，将根结点替换为一个较小的元素）时，我们需要**由上至下** 恢复堆的顺序 **sink()**。



## 堆表示

**二叉堆** 是一组能够用堆有序的完全二叉树排序的元素，并**在数组中按照层级储存（不使用数组的第一个位置）**。在一个堆中，位置 K 的结点的父结点的位置为 K/2，而它的两个子结点的位置则分别为 2K 和 2K +1。

这样在不使用指针的情况下也可以通过计算数组的索引在树中上下移动：从 `a[k]` 向上一层就令 `k` 等于 `k/2` ，向下一层则令 `k` 等于 `2k` 或 `2k+1` 。



# 散列表

## 简介

散列表也叫作**哈希表** （hash table），这种数据结构提供了**键（Key）** 和**值（Value）** 的映射关系。只要给出一个Key，就可以高效查找到它所匹配的Value，时间复杂度接近于 **O （1）** 

## 特点

- 查找和插入操作时间复杂度接近于 **O(1)**
- 实质是数组（+链表）。实际上是经过 hash 函数映射之后，等同于直接在数组中根据本下标进行操作。

## 扩容

### 为什么

当经过多次元素插入，散列表**达到一定饱和度**时，Key映射位置发生**冲突的概率会逐渐提高**。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。

这时，散列表就需要扩展它的长度，也就是进行**扩容** 。

对于JDK中的散列表实现类HashMap来说，影响其扩容的因素有两个。

· **Capacity** ，即HashMap的当前长度

· **LoadFactor** ，即HashMap的负载因子，默认值为0.75f

衡量HashMap需要进行扩容的条件如下。

**HashMap.Size＞=Capacity×LoadFactor**

### 过程

扩容不是简单地把散列表的长度扩大，而是经历了下面**两个步骤**。

1.**扩容** ，创建一个新的Entry空数组，长度是原数组的2倍。

2.**重新Hash** ，遍历原Entry数组，把所有的Entry重新Hash到新数组中。

为什么要重新Hash呢？**因为长度扩大以后，Hash的规则（hash计算和数组长度有关）也随之改变**。



## 举例

在Java及大多数面向对象的语言中，每一个对象都有属于自己的 hashcode，这个hashcode 是区分不同对象的重要标识。无论对象自身的类型是什么，它们的hashcode都是一个整型变量。

既然都是整型变量，想要转化成数组的下标也就不难实现了。最简单的转化方式是什么呢？是**按照数组长度进行取模运算**。

**index= HashCode (Key) % Array.length**

实际上，JDK（Java Development Kit，Java语言的软件开发工具包）中的哈希函数并没有直接采用取模运算，而是**利用了位运算的方式来优化性能**。不过在这里可以姑且简单理解成取模操作。